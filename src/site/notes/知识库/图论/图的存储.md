---
{"dg-publish":true,"permalink":"////"}
---

#图 
# ⭐链式前向星（各种情况最优）
需要准备
- `int h[MAX]` 存储头指针
- `int to[MAX]` 存储边的终点
- `int val[MAX]` 边的权
- `int nxt[MAX]` 下一条边指针
- `int cnt` 计数器
## 加边
```cpp
void add(int u, int v, int w) {
    to[++cnt] = v;      // 记录终点v到新边cnt
    val[cnt] = w;       // 记录权值w到新边cnt
    nxt[cnt] = h[u];    // 新边的下一条边是u原来的第一条边
    h[u] = cnt;         // 更新u的第一条边为当前新边
}
```
## 栗子🌰
#### **具体步骤**（假设初始 `h[u] = 0`，添加边 `u→A`、`u→B`）：

1. **添加第一条边 `u→A`（权值5）**
    
    - `cnt` 从0变为1。
    - `to[1] = A`, `val[1] = 5`。
    - `nxt[1] = h[u] = 0`（之前没有边）。
    - `h[u] = 1`（u的第一条边是1）。
    - **链表结构**：`u` → 边1（`A`,5） → 空。
2. **添加第二条边 `u→B`（权值3）**
    
    - `cnt` 变为2。
    - `to[2] = B`, `val[2] = 3`。
    - `nxt[2] = h[u] = 1`（新边的下一条是原来的第一条边1）。
    - `h[u] = 2`（u的第一条边更新为2）。
    - **链表结构**：`u` → 边2（`B`,3） → 边1（`A`,5） → 空。
## 遍历
```cpp
for (int i = h[u]; i; i = nxt[i]) { // 从u的第一条边开始，沿链表遍历
    int v = to[i];   // 当前边的终点
    int w = val[i];  // 当前边的权值
    // 进行松弛操作...
}
```
