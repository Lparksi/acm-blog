---
{"dg-publish":true,"permalink":"//2025/1-1/b/"}
---

#图论/树/哈密尔顿路径 

---
# 题目

$\hspace{15pt}$小红拿到了一棵树，她想请你寻找一条==简单路径==，使得这条路径不重不漏的经过所有节点。如果不存在这样的简单路径，则直接输出 $-1$。  
  
$\hspace{15pt}$简单路径是指这样一条路径，其经过的顶点和边互不相同。


---
# 输入输出
$\hspace{15pt}$第一行输入一个正整数 $n \left(2 \leq n \leq 10^5\right)$，代表树的节点数量。  
$\hspace{15pt}$此后 $n-1$ 行，第 $i$ 行输入两个正整数 $u_i,v_i \left(1 \leq u_i,v_i \leq n;\ u_i \neq v_i\right)$，代表第 $i$ 条边连接节点 $u_i$ 和节点 $v_i$。
$\hspace{15pt}$如果不存在这样的简单路径，直接输出 $-1$；否则，在一行上输出两个整数 $x,y$，代表你所找到的简单路径的==起点和终点==。  
$\hspace{15pt}$如果存在多个解决方案，您可以输出任意一个，系统会自动判定是否正确。注意，自测运行功能可能因此返回错误结果，请自行检查答案正确性。

---
# 样例

## 输入
```
4
1 3
2 1
3 4
```
# 输出
```
2 4
```
# 说明
在这个样例中，输出 `4 2` 也是正确的答案。

---
# 思路
本题的 *简单路径* 实际上指的是 [[知识库/图论/哈密尔顿路径#是什么\|哈密尔顿路径]]
换句话说，本题是要求能够 *一笔画* 地遍历这颗树的路径的开始与结束节点。
由 [[知识库/图论/哈密尔顿路径#判断\|判断方法]] 可知，如果一棵树**有且仅有 2 个叶子节点（度数为 1 的节点）** 时才存在解，否则直接输出 -1

---
# 做法
直接统计每个节点的 *度数* 。
用数组 deg（degree，度数） 存储
即对于题目上给出的每一个 边 (a, b) `deg[a]++; deg[b]++` 
这样可以统计处每一个节点的度数
构建答案数组 ans
遍历 deg 的每个节点
- 如果 `deg[i] == 1` 该节点是断点，`ans.push_back(i)`
- 如果 `deg[i] > 2` 该树不符合条件，直接 输出 `-1` 并退出
输出 ans

---
# 代码

```cpp
void solve() {
	int n;
	cin >> n;
	vector<int> in(n+1);
	for(int i=1;i<n;i++) {
		int u,v;
		cin >> u >> v;
		in[u]++;
		in[v]++;
	}
	vector<int> ans;
	for(int i=1;i<=n;i++) {
		if(in[i]==1) ans.push_back(i);
		if(in[i]>2) {
			cout <<-1<<endl;
			return;
		}
	}
	for(auto &i:ans) cout <<i<<" ";
	cout <<endl;
}
```
---
# 反思
要重视图论的学习。
了解图的各种形式与特点。

---
